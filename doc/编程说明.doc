遗留问题：
2017.4.5
1、调试时，当电池断开后，电池有电时，还在供电。这是设计输入决定的（当18V供电丢失时，应该能够保障通话功能 ),但是，研发调试或者生产调试中，这样做不完善。需要在什么机制下，
才保持断电通信功能。
最好是控制机能够在正常关机时，下发一条关机指令（已解决，延时一段时间后结束)
2 pwroff关断后，单片机并不能自断电,推测是Q3mos管有问题。手上没有相应的片子.（已经解决，是由于刘振兴封装做错了）
3、没有i2c存储器，用于存储数据.(已解决，新做了板子，并且调试成功4.22）
4、电源需要使用监控分院的电源模块


2017.4.5
	从刘振兴手里接收新闭锁程序。
	该程序已经完成了自动排序，打点，对讲功能。
1、使用该程序，无法获得can总线数据。从canbus分析仪上能看到接收数据数量在增长，但是没有数据显示。关闭软件cantest后，重启一次解决，应该是cantest软件的问题。
2、 if(Get_Key1() == 1)       //发声打点事件开始
		{
			Sine_Open();//打点开启
		}
		else 
		{
			Sine_Close();//打点关闭
		}
		这一句放在主程序里，会导致总线上不停的接收打点结束命令。此时总线负载比较重（无此必要）.使用一个flag解决这个问题。
		if(Get_Key1() == 1)       //发声打点事件开始
		{
			Sine_Open();//打点开启
			flag=1;
		}
		else if (flag==1)
		{
			Sine_Close();//打点关闭
			flag=0;
		}
3、使用keil5必须指定jlink仿真的单片机，否则一定会出现程序跑飞的问题。
4、主程序为
if(Get_Key1() == 1)       //发声对讲事件开始
		{
			key1_flag=true;
			Sine_Open();//打点开启
		}
		else if (key1_flag==true)
		{
		  key1_flag=false;
			Sine_Close();//打点关闭
		}
		if(Get_Key2() == 1)       //发声打点事件开始
		{
			key2_flag=true;
			Sine_Open();//打点开启
		}
		else if (key2_flag==true)
		{
		  key2_flag=false;
			Sine_Close();//打点关闭
		}
		
		
		if(flag_1000ms == 1)   //1000ms定时到，定时发送       
		{
			flag_1000ms = 0;
			
			can_data_send(id);                can发送为中断发送方式，可能会出现发送的数据被心跳数据改变的问题。
			
		}
		使用can_send_flag做保护。每次发送前，将can_send_flag置为true。发送完成后，置为false。
5、不能采用发命令方式让沿线各点打点。采用命令的方式打点，必须和每个节点都有确认机制，否则会出现有的喇叭不响，或者响起来停不下来的可能。但如果增加命令确认机制，那么一个点发出打点指令后，
沿线全部的喇叭都必须应答。不可取，因此，打点与语音对讲一样，必须是广播语音。
	
	
2017.4.6
1、pwroff关断后，单片机并不能自断电

2017.4.7
1、完成接收总线指令，调整音量
2、完成接收总线指令，调整充电电流
3、完成读取电池电压采集，在放音时采集。
4、调整功放打开功能.
5、实现播放完成才继续讲话
2017.4.11
1、基本完成闭锁的调试。
2、下一步完成新板子后，添加拉绳开关、跑偏信号的接入。
2017.4.17
1、已经完成跑偏信号的接入
2、遗留事件存储功能
3、完成授时功能
2017.4.22 
1、增加at24c16功能
2、增加闭锁、一级跑偏、二级跑偏的事件及其相应的释放事件的记录
3、修改can协议，增加flash记录清0事件 配置发送0x2 4 
4、需要增加批量上传的功能以及优化can事件的程序 
2017.4.23 
1、can发送中有点bug需要处理，发送的太快，总线收不到
2、增加延时函数解决问题。
2017.5.5 
1、上电后，会出现喇叭不受控响的现象，估计是ambe1000的初始化问题